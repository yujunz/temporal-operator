// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/alexandrevilain/temporal-operator/api/v1beta1

package v1beta1

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"github.com/gocql/gocql"
	networkingv1 "k8s.io/api/networking/v1"
	monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
)

// LogSpec contains the temporal logging configuration.
#LogSpec: {
	// Stdout is true if the output needs to goto standard out; default is stderr.
	// +optional
	// +kubebuilder:default=true
	stdout?: null | bool @go(Stdout,*bool)

	// Level is the desired log level; see colocated zap_logger.go::parseZapLevel()
	// +optional
	// +kubebuilder:validation:Enum=debug;info;warn;error;dpanic;panic;fatal
	// +kubebuilder:default=info
	level: string @go(Level)

	// OutputFile is the path to the log output file.
	// +optional
	outputFile: string @go(OutputFile)

	// Format determines the format of each log file printed to the output.
	// Use "console" if you want stack traces to appear on multiple lines.
	// +kubebuilder:validation:Enum=json;console
	// +kubebuilder:default=json
	// +optional
	format: string @go(Format)

	// Development determines whether the logger is run in Development (== Test) or in
	// Production mode.  Default is Production.  Production-stage disables panics from
	// DPanic logging.
	// +kubebuilder:default=false
	// +optional
	development: bool @go(Development)
}

// ServiceSpec contains a temporal service specifications.
#ServiceSpec: {
	// Port defines a custom gRPC port for the service.
	// Default values are:
	// 7233 for Frontend service
	// 7234 for History service
	// 7235 for Matching service
	// 7239 for Worker service
	// +optional
	port?: null | int @go(Port,*int)

	// MembershipPort defines a custom membership port for the service.
	// Default values are:
	// 6933 for Frontend service
	// 6934 for History service
	// 6935 for Matching service
	// 6939 for Worker service
	// +optional
	membershipPort?: null | int @go(MembershipPort,*int)

	// HTTPPort defines a custom http port for the service.
	// Default values are:
	// 7243 for Frontend service
	// +optional
	httpPort?: null | int @go(HTTPPort,*int)

	// Number of desired replicas for the service. Default to 1.
	// +kubebuilder:validation:Minimum=1
	// +optional
	replicas?: null | int32 @go(Replicas,*int32)

	// Compute Resources required by this service.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	// +optional
	resources?: corev1.#ResourceRequirements @go(Resources)

	// Overrides adds some overrides to the resources deployed for the service.
	// Those overrides takes precedence over spec.services.overrides.
	// +optional
	overrides?: null | #ServiceSpecOverride @go(Overrides,*ServiceSpecOverride)
}

// InternalFrontendServiceSpec contains temporal internal frontend service specifications.
#InternalFrontendServiceSpec: {
	#ServiceSpec

	// Enabled defines if we want to spawn the internal frontend service.
	// +optional
	// +kubebuilder:default:=false
	enabled?: bool @go(Enabled)
}

// ServicesSpec contains all temporal services specifications.
#ServicesSpec: {
	// Frontend service custom specifications.
	// +optional
	frontend?: null | #ServiceSpec @go(Frontend,*ServiceSpec)

	// Internal Frontend service custom specifications.
	// Only compatible with temporal >= 1.20.0
	// +optional
	internalFrontend?: null | #InternalFrontendServiceSpec @go(InternalFrontend,*InternalFrontendServiceSpec)

	// History service custom specifications.
	// +optional
	history?: null | #ServiceSpec @go(History,*ServiceSpec)

	// Matching service custom specifications.
	// +optional
	matching?: null | #ServiceSpec @go(Matching,*ServiceSpec)

	// Worker service custom specifications.
	// +optional
	worker?: null | #ServiceSpec @go(Worker,*ServiceSpec)

	// Overrides adds some overrides to the resources deployed for all temporal services services.
	// Those overrides can be customized per service using spec.services.<serviceName>.overrides.
	// +optional
	overrides?: null | #ServiceSpecOverride @go(Overrides,*ServiceSpecOverride)
}

// ServiceSpecOverride provides the ability to override the generated manifests of a temporal service.
#ServiceSpecOverride: {
	// Override configuration for the temporal service Deployment.
	deployment?: null | #DeploymentOverride @go(Deployment,*DeploymentOverride)
}

// DeploymentOverride provides the ability to override a Deployment.
#DeploymentOverride: {
	metadata?: null | #ObjectMetaOverride @go(ObjectMetaOverride,*ObjectMetaOverride)

	// Specification of the desired behavior of the Deployment.
	// +optional
	spec?: null | #DeploymentOverrideSpec @go(Spec,*DeploymentOverrideSpec)
}

// DeploymentOverrideSpec provides the ability to override a Deployment Spec.
// It's a subset of fields included in k8s.io/api/apps/v1.DeploymentSpec.
#DeploymentOverrideSpec: {
	// Template describes the pods that will be created.
	// +optional
	template?: null | #PodTemplateSpecOverride @go(Template,*PodTemplateSpecOverride)
}

// PodTemplateSpecOverride provides the ability to override a pod template spec.
// It's a subset of the fields included in k8s.io/api/core/v1.PodTemplateSpec.
#PodTemplateSpecOverride: {
	metadata?: null | #ObjectMetaOverride @go(ObjectMetaOverride,*ObjectMetaOverride)

	// Specification of the desired behavior of the pod.
	// +optional
	spec?: null | corev1.#PodSpec @go(Spec,*corev1.PodSpec)
}

// ObjectMetaOverride provides the ability to override an object metadata.
// It's a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
#ObjectMetaOverride: {
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects.
	// +optional
	labels?: {[string]: string} @go(Labels,map[string]string)

	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata.
	// +optional
	annotations?: {[string]: string} @go(Annotations,map[string]string)
}

// SecretKeyReference contains enough information to locate the referenced Kubernetes Secret object in the same
// namespace.
#SecretKeyReference: {
	// Name of the Secret.
	// +required
	name: string @go(Name)

	// Key in the Secret.
	// +optional
	key?: string @go(Key)
}

// SQLSpec contains SQL datastore connections specifications.
#SQLSpec: {
	// User is the username to be used for the connection.
	user: string @go(User)

	// PluginName is the name of SQL plugin.
	// +kubebuilder:validation:Enum=postgres;postgres12;mysql;mysql8
	pluginName: string @go(PluginName)

	// DatabaseName is the name of SQL database to connect to.
	databaseName: string @go(DatabaseName)

	// ConnectAddr is the remote addr of the database.
	connectAddr: string @go(ConnectAddr)

	// ConnectProtocol is the protocol that goes with the ConnectAddr.
	// +optional
	connectProtocol: string @go(ConnectProtocol)

	// ConnectAttributes is a set of key-value attributes to be sent as part of connect data_source_name url
	// +optional
	connectAttributes?: {[string]: string} @go(ConnectAttributes,map[string]string)

	// MaxConns the max number of connections to this datastore.
	// +optional
	maxConns: int @go(MaxConns)

	// MaxIdleConns is the max number of idle connections to this datastore.
	// +optional
	maxIdleConns: int @go(MaxIdleConns)

	// MaxConnLifetime is the maximum time a connection can be alive
	// +optional
	maxConnLifetime: metav1.#Duration @go(MaxConnLifetime)

	// TaskScanPartitions is the number of partitions to sequentially scan during ListTaskQueue operations.
	// +optional
	taskScanPartitions: int @go(TaskScanPartitions)
}

// DatastoreTLSSpec contains datastore TLS connections specifications.
#DatastoreTLSSpec: {
	// Enabled defines if the cluster should use a TLS connection to connect to the datastore.
	enabled: bool @go(Enabled)

	// CertFileRef is a reference to a secret containing the cert file.
	// +optional
	certFileRef?: null | #SecretKeyReference @go(CertFileRef,*SecretKeyReference)

	// KeyFileRef is a reference to a secret containing the key file.
	// +optional
	keyFileRef?: null | #SecretKeyReference @go(KeyFileRef,*SecretKeyReference)

	// CaFileRef is a reference to a secret containing the ca file.
	// +optional
	caFileRef?: null | #SecretKeyReference @go(CaFileRef,*SecretKeyReference)

	// EnableHostVerification defines if the hostname should be verified when connecting to the datastore.
	enableHostVerification: bool @go(EnableHostVerification)

	// ServerName the datastore should present.
	// +optional
	serverName: string @go(ServerName)
}

// ElasticsearchIndices holds index names.
#ElasticsearchIndices: {
	// Visibility defines visibility's index name.
	// +kubebuilder:default=temporal_visibility_v1
	visibility: string @go(Visibility)

	// SecondaryVisibility defines secondary visibility's index name.
	// +optional
	secondaryVisibility: string @go(SecondaryVisibility)
}

// ElasticsearchSpec contains Elasticsearch datastore connections specifications.
#ElasticsearchSpec: {
	// Version defines the elasticsearch version.
	// +kubebuilder:default=v7
	// +kubebuilder:validation:Pattern=`^v(6|7|8)$`
	version: string @go(Version)

	// URL is the connection url to connect to the instance.
	// +kubebuilder:validation:Pattern=`^https?:\/\/.+$`
	url: string @go(URL)

	// Username is the username to be used for the connection.
	username: string @go(Username)

	// Indices holds visibility index names.
	indices: #ElasticsearchIndices @go(Indices)

	// LogLevel defines the temporal cluster's es client logger level.
	// +optional
	logLevel: string @go(LogLevel)

	// CloseIdleConnectionsInterval is the max duration a connection stay open while idle.
	// +optional
	closeIdleConnectionsInterval: metav1.#Duration @go(CloseIdleConnectionsInterval)

	// EnableSniff enables or disables sniffer on the temporal cluster's es client.
	// +optional
	enableSniff: bool @go(EnableSniff)

	// EnableHealthcheck enables or disables healthcheck on the temporal cluster's es client.
	// +optional
	enableHealthcheck: bool @go(EnableHealthcheck)
}

// CassandraConsistencySpec sets the consistency level for regular & serial queries to Cassandra.
#CassandraConsistencySpec: {
	// Consistency sets the default consistency level.
	// Values identical to gocql Consistency values. (defaults to LOCAL_QUORUM if not set).
	// +kubebuilder:validation:Enum=ANY;ONE;TWO;THREE;QUORUM;ALL;LOCAL_QUORUM;EACH_QUORUM;LOCAL_ONE
	// +optional
	consistency?: null | gocql.#Consistency @go(Consistency,*gocql.Consistency)

	// SerialConsistency sets the consistency for the serial prtion of queries. Values identical to gocql SerialConsistency values.
	// (defaults to LOCAL_SERIAL if not set)
	// +kubebuilder:validation:Enum=SERIAL;LOCAL_SERIAL
	// +optional
	serialConsistency?: null | gocql.#SerialConsistency @go(SerialConsistency,*gocql.SerialConsistency)
}

// CassandraSpec contains cassandra datastore connections specifications.
#CassandraSpec: {
	// Hosts is a list of cassandra endpoints.
	hosts: [...string] @go(Hosts,[]string)

	// Port is the cassandra port used for connection by gocql client.
	port: int @go(Port)

	// User is the cassandra user used for authentication by gocql client.
	user: string @go(User)

	// Keyspace is the cassandra keyspace.
	keyspace: string @go(Keyspace)

	// Datacenter is the data center filter arg for cassandra.
	datacenter: string @go(Datacenter)

	// MaxConns is the max number of connections to this datastore for a single keyspace.
	// +optional
	maxConns: int @go(MaxConns)

	// ConnectTimeout is a timeout for initial dial to cassandra server.
	// +optional
	connectTimeout?: null | metav1.#Duration @go(ConnectTimeout,*metav1.Duration)

	// Consistency configuration.
	// +optional
	consistency?: null | #CassandraConsistencySpec @go(Consistency,*CassandraConsistencySpec)

	// DisableInitialHostLookup instructs the gocql client to connect only using the supplied hosts.
	// +optional
	disableInitialHostLookup: bool @go(DisableInitialHostLookup)
}

#DatastoreType: string // #enumDatastoreType

#enumDatastoreType:
	#CassandraDatastore |
	#PostgresSQLDatastore |
	#PostgresSQL12Datastore |
	#MySQLDatastore |
	#MySQL8Datastore |
	#ElasticsearchDatastore |
	#UnknownDatastore

#CassandraDatastore:     #DatastoreType & "cassandra"
#PostgresSQLDatastore:   #DatastoreType & "postgres"
#PostgresSQL12Datastore: #DatastoreType & "postgres12"
#MySQLDatastore:         #DatastoreType & "mysql"
#MySQL8Datastore:        #DatastoreType & "mysql8"
#ElasticsearchDatastore: #DatastoreType & "elasticsearch"
#UnknownDatastore:       #DatastoreType & "unknown"

#DefaultStoreName:             "default"
#VisibilityStoreName:          "visibility"
#SecondaryVisibilityStoreName: "secondaryVisibility"
#AdvancedVisibilityStoreName:  "advancedVisibility"

// DatastoreSpec contains temporal datastore specifications.
#DatastoreSpec: {
	// Name is the name of the datastore.
	// It should be unique and will be referenced within the persitence spec.
	// Defaults to "default" for default sore, "visibility" for visibility store,
	// "secondaryVisibility" for secondary visibility store and
	// "advancedVisibility" for advanced visibility store.
	// +optional
	name: string @go(Name)

	// SQL holds all connection parameters for SQL datastores.
	// +optional
	sql?: null | #SQLSpec @go(SQL,*SQLSpec)

	// Elasticsearch holds all connection parameters for Elasticsearch datastores.
	// +optional
	elasticsearch?: null | #ElasticsearchSpec @go(Elasticsearch,*ElasticsearchSpec)

	// Cassandra holds all connection parameters for Cassandra datastore.
	// Note that cassandra is now deprecated for visibility store.
	// +optional
	cassandra?: null | #CassandraSpec @go(Cassandra,*CassandraSpec)

	// PasswordSecret is the reference to the secret holding the password.
	// +required
	passwordSecretRef: #SecretKeyReference @go(PasswordSecretRef)

	// TLS is an optional option to connect to the datastore using TLS.
	// +optional
	tls?: null | #DatastoreTLSSpec @go(TLS,*DatastoreTLSSpec)

	// SkipCreate instructs the operator to skip creating the database for SQL datastores or to skip creating keyspace for Cassandra. Use this option if your database or keyspace has already been provisioned by an administrator.
	// +optional
	skipCreate: bool @go(SkipCreate)
}

_#dataStoreTLSCertificateBasePath: "/etc/tls/datastores"
#DataStoreClientTLSCertFileName:   "client.pem"
#DataStoreClientTLSKeyFileName:    "client.key"
#DataStoreClientTLSCaFileName:     "ca.pem"

// TemporalPersistenceSpec contains temporal persistence specifications.
#TemporalPersistenceSpec: {
	// DefaultStore holds the default datastore specs.
	defaultStore?: null | #DatastoreSpec @go(DefaultStore,*DatastoreSpec)

	// VisibilityStore holds the visibility datastore specs.
	visibilityStore?: null | #DatastoreSpec @go(VisibilityStore,*DatastoreSpec)

	// SecondaryVisibilityStore holds the secondary visibility datastore specs.
	// Feature only available for clusters >= 1.21.0.
	// +optional
	secondaryVisibilityStore?: null | #DatastoreSpec @go(SecondaryVisibilityStore,*DatastoreSpec)

	// AdvancedVisibilityStore holds the avanced visibility datastore specs.
	// +optional
	advancedVisibilityStore?: null | #DatastoreSpec @go(AdvancedVisibilityStore,*DatastoreSpec)
}

// TemporalUIIngressSpec contains all configurations options for the UI ingress.
#TemporalUIIngressSpec: {
	// Annotations allows custom annotations on the ingress ressource.
	annotations?: {[string]: string} @go(Annotations,map[string]string)

	// IngressClassName is the name of the IngressClass the deployed ingress resource should use.
	ingressClassName?: null | string @go(IngressClassName,*string)

	// Host is the list of host the ingress should use.
	hosts: [...string] @go(Hosts,[]string)

	// TLS configuration.
	tls?: [...networkingv1.#IngressTLS] @go(TLS,[]networkingv1.IngressTLS) @protobuf(2,bytes,rep)
}

// TemporalUISpec defines parameters for the temporal UI within a Temporal cluster deployment.
#TemporalUISpec: {
	// Enabled defines if the operator should deploy the web ui alongside the cluster.
	// +optional
	enabled: bool @go(Enabled)

	// Version defines the temporal ui version the instance should run.
	// +optional
	version: string @go(Version)

	// Image defines the temporal ui docker image the instance should run.
	// +optional
	image: string @go(Image)

	// Number of desired replicas for the ui. Default to 1.
	// +kubebuilder:validation:Minimum=1
	// +optional
	replicas?: null | int32 @go(Replicas,*int32)

	// Compute Resources required by the ui.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	// +optional
	resources?: corev1.#ResourceRequirements @go(Resources)

	// Overrides adds some overrides to the resources deployed for the ui.
	// +optional
	overrides?: null | #ServiceSpecOverride @go(Overrides,*ServiceSpecOverride)

	// Ingress is an optional ingress configuration for the UI.
	// If lived empty, no ingress configuration will be created and the UI will only by available trough ClusterIP service.
	// +optional
	ingress?: null | #TemporalUIIngressSpec @go(Ingress,*TemporalUIIngressSpec)

	// Service is an optional service resource configuration for the UI.
	// +optional
	service?: null | #ObjectMetaOverride @go(Service,*ObjectMetaOverride)
}

// TemporalAdminToolsSpec defines parameters for the temporal admin tools within a Temporal cluster deployment.
// Note that deployed admin tools version is the same as the cluster's version.
#TemporalAdminToolsSpec: {
	// Enabled defines if the operator should deploy the admin tools alongside the cluster.
	// +optional
	enabled: bool @go(Enabled)

	// Image defines the temporal admin tools docker image the instance should run.
	// +optional
	image: string @go(Image)

	// Compute Resources required by the ui.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	// +optional
	resources?: corev1.#ResourceRequirements @go(Resources)

	// Overrides adds some overrides to the resources deployed for the ui.
	// +optional
	overrides?: null | #ServiceSpecOverride @go(Overrides,*ServiceSpecOverride)
}

// MTLSProvider is the enum for support mTLS provider.
#MTLSProvider: string // #enumMTLSProvider

#enumMTLSProvider:
	#CertManagerMTLSProvider |
	#LinkerdMTLSProvider |
	#IstioMTLSProvider

// CertManagerMTLSProvider uses cert-manager to manage mTLS certificate.
#CertManagerMTLSProvider: #MTLSProvider & "cert-manager"
#LinkerdMTLSProvider:     #MTLSProvider & "linkerd"
#IstioMTLSProvider:       #MTLSProvider & "istio"

// FrontendMTLSSpec defines parameters for the temporal encryption in transit with mTLS.
#FrontendMTLSSpec: {
	// Enabled defines if the operator should enable mTLS for cluster's public endpoints.
	// +optional
	enabled: bool @go(Enabled)
}

// InternodeMTLSSpec defines parameters for the temporal encryption in transit with mTLS.
#InternodeMTLSSpec: {
	// Enabled defines if the operator should enable mTLS for network between cluster nodes.
	// +optional
	enabled: bool @go(Enabled)
}

// CertificatesDurationSpec defines parameters for the temporal mTLS certificates duration.
#CertificatesDurationSpec: {
	// RootCACertificate is the 'duration' (i.e. lifetime) of the Root CA Certificate.
	// It defaults to 10 years.
	// +optional
	rootCACertificate?: null | metav1.#Duration @go(RootCACertificate,*metav1.Duration)

	// IntermediateCACertificates is the 'duration' (i.e. lifetime) of the intermediate CAs Certificates.
	// It defaults to 5 years.
	// +optional
	intermediateCAsCertificates?: null | metav1.#Duration @go(IntermediateCAsCertificates,*metav1.Duration)

	// ClientCertificates is the 'duration' (i.e. lifetime) of the client certificates.
	// It defaults to 1 year.
	// +optional
	clientCertificates?: null | metav1.#Duration @go(ClientCertificates,*metav1.Duration)

	// FrontendCertificate is the 'duration' (i.e. lifetime) of the frontend certificate.
	// It defaults to 1 year.
	// +optional
	frontendCertificate?: null | metav1.#Duration @go(FrontendCertificate,*metav1.Duration)

	// InternodeCertificate is the 'duration' (i.e. lifetime) of the internode certificate.
	// It defaults to 1 year.
	// +optional
	internodeCertificate?: null | metav1.#Duration @go(InternodeCertificate,*metav1.Duration)
}

// MTLSSpec defines parameters for the temporal encryption in transit with mTLS.
#MTLSSpec: {
	// Provider defines the tool used to manage mTLS certificates.
	// +kubebuilder:default=cert-manager
	// +kubebuilder:validation:Enum=cert-manager;linkerd;istio
	// +optional
	provider: #MTLSProvider @go(Provider)

	// Internode allows configuration of the internode traffic encryption.
	// Useless if mTLS provider is not cert-manager.
	// +optional
	internode?: null | #InternodeMTLSSpec @go(Internode,*InternodeMTLSSpec)

	// Frontend allows configuration of the frontend's public endpoint traffic encryption.
	// Useless if mTLS provider is not cert-manager.
	// +optional
	frontend?: null | #FrontendMTLSSpec @go(Frontend,*FrontendMTLSSpec)

	// CertificatesDuration allows configuration of maximum certificates lifetime.
	// Useless if mTLS provider is not cert-manager.
	// +optional
	certificatesDuration?: null | #CertificatesDurationSpec @go(CertificatesDuration,*CertificatesDurationSpec)

	// RefreshInterval defines interval between refreshes of certificates in the cluster components.
	// Defaults to 1 hour.
	// Useless if mTLS provider is not cert-manager.
	// +optional
	refreshInterval?: null | metav1.#Duration @go(RefreshInterval,*metav1.Duration)

	// RenewBefore is defines how long before the currently issued certificate's expiry
	// cert-manager should renew the certificate. The default is 2/3 of the
	// issued certificate's duration. Minimum accepted value is 5 minutes.
	// Useless if mTLS provider is not cert-manager.
	// +optional
	renewBefore?: null | metav1.#Duration @go(RenewBefore,*metav1.Duration)
}

// PrometheusScrapeConfigServiceMonitor is the configuration for prometheus operator ServiceMonitor.
#PrometheusScrapeConfigServiceMonitor: {
	// Enabled defines if the operator should create a ServiceMonitor for each services.
	// +optional
	enabled: bool @go(Enabled)

	// Labels adds extra labels to the ServiceMonitor.
	// +optional
	labels?: {[string]: string} @go(Labels,map[string]string)

	// Override allows customization of the created ServiceMonitor.
	// All fields can be overritten except "endpoints", "selector" and "namespaceSelector".
	// +optional
	override?: null | monitoringv1.#ServiceMonitorSpec @go(Override,*monitoringv1.ServiceMonitorSpec)

	// MetricRelabelConfigs to apply to samples before ingestion.
	// +optional
	metricRelabelings?: [...null | monitoringv1.#RelabelConfig] @go(MetricRelabelConfigs,[]*monitoringv1.RelabelConfig)
}

// PrometheusScrapeConfig is the configuration for making prometheus scrape components metrics.
#PrometheusScrapeConfig: {
	// Annotations defines if the operator should add prometheus scrape annotations to the services pods.
	// +optional
	annotations: bool @go(Annotations)

	// +optional
	serviceMonitor?: null | #PrometheusScrapeConfigServiceMonitor @go(ServiceMonitor,*PrometheusScrapeConfigServiceMonitor)
}

// PrometheusSpec is the configuration for prometheus reporter.
#PrometheusSpec: {
	// Deprecated. Address for prometheus to serve metrics from.
	// +optional
	// +deprecated
	listenAddress: string @go(ListenAddress)

	// ListenPort for prometheus to serve metrics from.
	// +optional
	listenPort?: null | int32 @go(ListenPort,*int32)

	// ScrapeConfig is the prometheus scrape configuration.
	// +optional
	scrapeConfig?: null | #PrometheusScrapeConfig @go(ScrapeConfig,*PrometheusScrapeConfig)
}

// MetricsSpec determines parameters for configuring metrics endpoints.
#MetricsSpec: {
	// Enabled defines if the operator should enable metrics exposition on temporal components.
	enabled: bool @go(Enabled)

	// Prometheus reporter configuration.
	// +optional
	prometheus?: null | #PrometheusSpec @go(Prometheus,*PrometheusSpec)
}

// Constraints is an alias for temporal's dynamicconfig.Constraints.
// It describes under what conditions a ConstrainedValue should be used.
#Constraints: {
	// +optional
	namespace: string @go(Namespace)

	// +optional
	namespaceId: string @go(NamespaceID)

	// +optional
	taskQueueName: string @go(TaskQueueName)

	// +optional
	taskQueueType: string @go(TaskQueueType)

	// +optional
	shardId: int32 @go(ShardID)

	// +optional
	taskType: string @go(TaskType)
}

// ConstrainedValue is an alias for temporal's dynamicconfig.ConstrainedValue.
#ConstrainedValue: {
	// Constraints describe under what conditions a ConstrainedValue should be used.
	// +optional
	constraints: #Constraints @go(Constraints)

	// Value is the value for the configuration key.
	// The type of the Value field depends on the key.
	// Acceptable types will be one of: int, float64, bool, string, map[string]any, time.Duration
	value?: null | apiextensionsv1.#JSON @go(Value,*apiextensionsv1.JSON)
}

// DynamicConfigSpec is the configuration for temporal dynamic config.
#DynamicConfigSpec: {
	// PollInterval defines how often the config should be updated by checking provided values.
	// Defaults to 10s.
	// +optional
	pollInterval?: null | metav1.#Duration @go(PollInterval,*metav1.Duration)

	// Values contains all dynamic config keys and their constained values.
	values: {[string]: [...#ConstrainedValue]} @go(Values,map[string][]ConstrainedValue)
}

// ClusterArchivalSpec is the configuration for cluster-wide archival config.
#ClusterArchivalSpec: {
	// Enabled defines if the archival is enabled for the cluster.
	// +kubebuilder:default:=false
	// +optional
	enabled: bool @go(Enabled)

	// Provider defines the archival provider for the cluster.
	// The same provider is used for both history and visibility,
	// but some config can be changed using spec.archival.[history|visibility].config.
	// +optional
	provider?: null | #ArchivalProvider @go(Provider,*ArchivalProvider)

	// History is the default config for the history archival.
	// +optional
	history?: null | #ArchivalSpec @go(History,*ArchivalSpec)

	// Visibility is the default config for visibility archival.
	// +optional
	visibility?: null | #ArchivalSpec @go(Visibility,*ArchivalSpec)
}

#ArchivalProviderKind: string // #enumArchivalProviderKind

#enumArchivalProviderKind:
	#FileStoreArchivalProviderKind |
	#S3ArchivalProviderKind |
	#GCSArchivalProviderKind |
	#UnknownArchivalProviderKind

#FileStoreArchivalProviderKind: #ArchivalProviderKind & "filestore"
#S3ArchivalProviderKind:        #ArchivalProviderKind & "s3"
#GCSArchivalProviderKind:       #ArchivalProviderKind & "gcs"
#UnknownArchivalProviderKind:   #ArchivalProviderKind & "unknown"

// ArchivalProvider contains the config for archivers.
#ArchivalProvider: {
	// +optional
	filestore?: null | #FilestoreArchiver @go(Filestore,*FilestoreArchiver)

	// +optional
	s3?: null | #S3Archiver @go(S3,*S3Archiver)

	// +optional
	gcs?: null | #GCSArchiver @go(GCS,*GCSArchiver)
}

// ArchivalSpec is the archival configuration for a particular persistence type (history or visibilitty).
#ArchivalSpec: {
	// Enabled defines if the archival is enabled by default for all namespaces
	// or for a particular namespace (depends if it's for a TemporalCluster or a TemporalNamespace).
	// +kubebuilder:default:=false
	// +optional
	enabled: bool @go(Enabled)

	// Paused defines if the archival is paused.
	// +kubebuilder:default:=false
	paused: bool @go(Paused)

	// EnableRead allows temporal to read from the archived Event History.
	// +kubebuilder:default:=false
	enableRead: bool @go(EnableRead)

	// Path is ...
	// +kubebuilder:validation:Required
	path: string @go(Path)
}

// FilestoreArchiver is the file store archival provider configuration.
#FilestoreArchiver: {
	// FilePermissions sets the file permissions of the archived files.
	// It's recommend to leave it empty and use the default value of "0666" to avoid read/write issues.
	// +kubebuilder:default:="0666"
	filePermissions: string @go(FilePermissions)

	// DirPermissions sets the directory permissions of the archive directory.
	// It's recommend to leave it empty and use the default value of "0766" to avoid read/write issues.
	// +kubebuilder:default:="0766"
	dirPermissions: string @go(DirPermissions)
}

// S3Archiver is the S3 archival provider configuration.
#S3Archiver: {
	// Region is the aws s3 region.
	// +kubebuilder:validation:Required
	region: string @go(Region)

	// Use Endpoint if you want to use s3-compatible object storage.
	// +optional
	endpoint?: null | string @go(Endpoint,*string)

	// Use RoleName if you want the temporal service account
	// to assume an AWS Identity and Access Management (IAM) role.
	// +optional
	roleName?: null | string @go(RoleName,*string)

	// Use credentials if you want to use aws credentials from secret.
	// +optional
	credentials?: null | #S3Credentials @go(Credentials,*S3Credentials)

	// Use s3ForcePathStyle if you want to use s3 path style.
	// +optional
	s3ForcePathStyle: bool @go(S3ForcePathStyle)
}

#S3Credentials: {
	// AccessKeyIDRef is the secret key selector containing AWS access key ID.
	// +kubebuilder:validation:Required
	accessKeyIdRef?: null | corev1.#SecretKeySelector @go(AccessKeyIDRef,*corev1.SecretKeySelector)

	// SecretAccessKeyRef is the secret key selector containing AWS secret access key.
	// +kubebuilder:validation:Required
	secretKeyRef?: null | corev1.#SecretKeySelector @go(SecretAccessKeyRef,*corev1.SecretKeySelector)
}

// GCSArchiver is the GCS archival provider configuration.
#GCSArchiver: {
	// SecretAccessKeyRef is the secret key selector containing Google Cloud Storage credentials file.
	// +kubebuilder:validation:Required
	credentialsRef?: null | corev1.#SecretKeySelector @go(CredentialsRef,*corev1.SecretKeySelector)
}

// TemporalClusterSpec defines the desired state of Cluster.
#TemporalClusterSpec: {
	// Image defines the temporal server docker image the cluster should use for each services.
	// +optional
	image: string @go(Image)

	// Log defines temporal cluster's logger configuration.
	// +optional
	log?: null | #LogSpec @go(Log,*LogSpec)

	// JobTTLSecondsAfterFinished is amount of time to keep job pods after jobs are completed.
	// Defaults to 300 seconds.
	// +optional
	//+kubebuilder:default:=300
	//+kubebuilder:validation:Minimum=1
	jobTtlSecondsAfterFinished?: null | int32 @go(JobTTLSecondsAfterFinished,*int32)

	// JobResources allows set resources for setup/update jobs.
	// +optional
	jobResources?: corev1.#ResourceRequirements @go(JobResources)

	// NumHistoryShards is the desired number of history shards.
	// This field is immutable.
	//+kubebuilder:validation:Minimum=1
	numHistoryShards: int32 @go(NumHistoryShards)

	// Services allows customizations for each temporal services deployment.
	// +optional
	services?: null | #ServicesSpec @go(Services,*ServicesSpec)

	// Persistence defines temporal persistence configuration.
	persistence: #TemporalPersistenceSpec @go(Persistence)

	// An optional list of references to secrets in the same namespace
	// to use for pulling temporal images from registries.
	// +optional
	imagePullSecrets?: [...corev1.#LocalObjectReference] @go(ImagePullSecrets,[]corev1.LocalObjectReference)

	// UI allows configuration of the optional temporal web ui deployed alongside the cluster.
	// +optional
	ui?: null | #TemporalUISpec @go(UI,*TemporalUISpec)

	// AdminTools allows configuration of the optional admin tool pod deployed alongside the cluster.
	// +optional
	admintools?: null | #TemporalAdminToolsSpec @go(AdminTools,*TemporalAdminToolsSpec)

	// MTLS allows configuration of the network traffic encryption for the cluster.
	// +optional
	mTLS?: null | #MTLSSpec @go(MTLS,*MTLSSpec)

	// Metrics allows configuration of scraping endpoints for stats. prometheus or m3.
	// +optional
	metrics?: null | #MetricsSpec @go(Metrics,*MetricsSpec)

	// DynamicConfig allows advanced configuration for the temporal cluster.
	// +optional
	dynamicConfig?: null | #DynamicConfigSpec @go(DynamicConfig,*DynamicConfigSpec)

	// Archival allows Workflow Execution Event Histories and Visibility data backups for the temporal cluster.
	// +optional
	archival?: null | #ClusterArchivalSpec @go(Archival,*ClusterArchivalSpec)
}

// ServiceStatus reports a service status.
#ServiceStatus: {
	// Name of the temporal service.
	name: string @go(Name)

	// Current observed version of the service.
	version: string @go(Version)

	// Ready defines if the service is ready.
	ready: bool @go(Ready)
}

// DatastoreStatus contains the current status of a datastore.
#DatastoreStatus: {
	// Created indicates if the database or keyspace has been created.
	created: bool @go(Created)

	// Setup indicates if tables have been set up.
	setup: bool @go(Setup)

	// Type indicates the datastore stype.
	// +optional
	type: #DatastoreType @go(Type)
}

// TemporalPersistenceStatus contains temporal persistence status.
#TemporalPersistenceStatus: {
	// DefaultStore holds the default datastore status.
	defaultStore?: null | #DatastoreStatus @go(DefaultStore,*DatastoreStatus)

	// VisibilityStore holds the visibility datastore status.
	visibilityStore?: null | #DatastoreStatus @go(VisibilityStore,*DatastoreStatus)

	// SecondaryVisibilityStore holds the secondary visibility datastore status.
	// +optional
	secondaryVisibilityStore?: null | #DatastoreStatus @go(SecondaryVisibilityStore,*DatastoreStatus)

	// AdvancedVisibilityStore holds the avanced visibility datastore status.
	// +optional
	advancedVisibilityStore?: null | #DatastoreStatus @go(AdvancedVisibilityStore,*DatastoreStatus)
}

// TemporalClusterStatus defines the observed state of Cluster.
#TemporalClusterStatus: {
	// Version holds the current temporal version.
	version?: string @go(Version)

	// Services holds all services statuses.
	services?: [...#ServiceStatus] @go(Services,[]ServiceStatus)

	// Persistence holds all datastores statuses.
	persistence?: null | #TemporalPersistenceStatus @go(Persistence,*TemporalPersistenceStatus)

	// Conditions represent the latest available observations of the Cluster state.
	conditions: [...metav1.#Condition] @go(Conditions,[]metav1.Condition)
}

// TemporalCluster defines a temporal cluster deployment.
#TemporalCluster: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Specification of the desired behavior of the Temporal cluster.
	spec?: #TemporalClusterSpec @go(Spec)

	// Most recent observed status of the Temporal cluster.
	status?: #TemporalClusterStatus @go(Status)
}

// TemporalClusterList contains a list of Cluster.
#TemporalClusterList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#TemporalCluster] @go(Items,[]TemporalCluster)
}
